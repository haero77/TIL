#JPA #연관관계 #N플러스1


![](attachments/Pasted%20image%2020231011055310.png)

*(영한님이 양방향 연관 관계를 뜯어 말리셨던 이유를 몸소 체험했다...)*

# 들어가며
---

요새 Admin 최적화 업무를 많이 맡고 있다. 특히 대부분의 경우가 API 성능 문제인데, 대개는 N + 1 문제로 인한 속도 저하였다. 문제는 조회 로직에서 양방향 연관 관계 필드를 이용해서 `getter` 위주로 조회한 다음에 `Mapstruct` 를 이용하는 Mapper 와 연계해서 화면에 Response를 내려주다보니, 단순히 `페치 조인`이나 `@BatchSize` 등으로는 해결되지 않는 경우가 다반사라는 것이다. 그래서 조회 로직을 완전히 새로 짤 수밖에 없었고, 예상치 못하게 시간을 많이 쓰게되었다. 이번 포스팅에서는 해당 경험담을 바탕으로, 왜 `양방향 연관 관계`를 쓰면 앞으로의 유지보수가 많이 힘들어지는지, 또 앞으로 레거시를 어떻게 개선해나가야할지 등에 대해 간단히 생각을 남겨본다.


# 본문
---

## 양방향 연관 관계를 왜 썼을까

레거시가 너무 복잡해서 최적화하기 어렵다고 좌절하기 전에, 먼저 왜 `양방향 연관 관계(이하 양방향)`를 썼을까 하고 추측해봤다. `양방향`을 쓰면 아무래도 연관 있는 엔티티를 조회하기가 편하다. 리포지토리에 별도의 메서드를 정의 안하고 `getter` 한 번 사용하면 되니까 간단한 로직같은 경우 제법 유용하게 쓸 수도 있기도 하고. 나 역시 [불과 얼마전까지만해도 토이 프로젝트에서 편하다는 이유로 양방향 연관관계를 즐겨쓰곤 했던터라](https://velog.io/@balparang/JPA-컬렉션-엔티티와-페이징을-함께-사용하기-feat.-BatchSize), 그 마음을 충분히 이해한다. 하물며 당시에 이 코드를 작성한 개발자는 성능까지 고려하며 개발할 시간적 여유가 부족했을 것이고, 그래서 일단 구현하기 위해서 사용했을 것이다. 그런데 문제는 다른 개발자들도 하나둘씩 이 `양방향` 이 가져다주는 편리함을 이용해서 또 새로운 로직을 만들고, 결국 성능 문제와 같은 사이드 이펙트가 발생해서 '자 이제 리팩토링 해야겠어'라고 생각했을 때는 이미 손 쓰기 힘든 코드가 된다는 것이다.


## 무슨 문제가 있나

실제로 `양방향` 을 쓰면 무슨 문제가 있는지 코드를 보면서 이해해보자. 회사 코드는 보안상 그대로 사용하기 어려우므로, 설명하기 좋은 예제를 가져왔다. 영한님 JPA 강의에서 많이 사용되는 `Member` 와 `Team` 엔티티 예제이다.

```java
@Entity  
@NoArgsConstructor(access = AccessLevel.PROTECTED)  
@Getter  
public class Member {  
  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    @Column(name = "member_id")  
    private Long id;  
  
    private String username;  
  
    @ManyToOne(fetch = FetchType.LAZY)  
    @JoinColumn(name = "team_id")  
    private Team team;  
  
    @Builder  
    protected Member(String username) {  
        this.username = username;  
    }  
  
    public static Member from(String username) {  
        return Member.builder()  
                .username(username)  
                .build();  
    }  
  
    public void changeTeam(Team team) {  
        if (this.team != null) { // 기존 팀과 연관 관계 제거  
            this.team.removeMember(this);  
        }  
  
        this.team = team;  
        team.addMember(this);  
    }  
  
}
```

```java
@Entity  
@NoArgsConstructor(access = AccessLevel.PROTECTED)  
public class Team {  
  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    @Column(name = "team_id")  
    private Long id;  
  
    private String name;  
  
    @OneToMany(mappedBy = "team")  
    private final List<Member> members = new ArrayList<>();  
  
    @Builder  
    protected Team(String name) {  
        this.name = name;  
    }  
  
    public static Team from(String name) {  
        return Team.builder()  
                .name(name)  
                .build();  
    }
  
    public void addMember(Member member) {  
        this.members.add(member);  
    }  
  
    public void removeMember(Member member) {  
        this.members.remove(member);  
    }  
  
}
```

`Member` 와 `Team` 은 1:N 관계이고, `Member` -> `@ManyToOne` -> `Team` / `Team` -> `@OneToMany` -> `Member` 으로 양방향 매핑되어있다. 이제 요구사항을 하나씩 추가해보면서 어떤 경우에 문제가 되는지 살펴보자.


### 모든 로직을 getter 를 이용해서 풀게 된다

- *특정 팀의 멤버 중 username 이 "member1" 인 Member 를 조회한다.*

라는 요구사항이 있다고 가정하자(여기서 특정 팀이라는 것은 복수 개가 될 수 있다). 위 요구사항을 내가 구현한다면 Member 를 대상으로 질의를 할 때 팀을 조인하여 구현할 것 같다. 그러나, 아쉽게도 기존 코드는 내 바램과는 다르게 다음처럼 구현되어있었다.

```java
List<Team> teams = teamRepository.findAllByIdIn(teamIds);
for (Team team : teams) {
	team.findMembersBy("member1");
}
```
```java
public class Team {  
  
	... 
  
    @OneToMany(mappedBy = "team")  
    private List<Member> members = new ArrayList<>();  

	...
  
    public List<Member> findMembersBy(String username) {  
        return this.members.stream()  
                .filter(member -> member.getUsername().equals(username))  
                .collect(Collectors.toList());  
    }  
  
	...
  
}
```

즉, 팀의 연관 관계 필드를 가지고 조회 로직이 구성되다 보니, Lazy Loading 으로 인해 `N + 1 문제`가 발생하는 것이다.

![](attachments/Pasted%20image%2020231011083954.png)

해결할 방법이 없냐고 하면 그렇지만은 않다. 

그런데 문제는 

심지어 이 `findMembersBy()`

심정은 정말이지 울고 싶었다.

![300](attachments/Pasted%20image%2020231011074810.png)
*(울고 싶었다.)*

`Member` 를 기준으로 Team 을 

`양방향` 자체가 문제라기 보다도, 이 `양방향` 이 이미 필드로 존재하다 보니까 욕구가 들 수 밖에 없었을 것이다. 그게 아무래도 쉽고 빠른 길이니까.

일단 양방향 연관 관계를 만들어두면, 

그러니까 이런 문제들은 근본적으로 `양방향`을 없애지 않고서는 해결할 수 없는 문제이다. 

다른 팀원들이 이렇게 코딩하는 것을 막기 위해서라도, 
쉽게 말하면 `객체 그래프 탐색 기능`을 넘어서, 비즈니스 로직까지 해결하려다 
수많은 로직을 

### 큰 고민을 안 하게 된다





## 어떻게 해결할까


기존 로직을 하나씩 제거해나가면서 
사실상 하드 코딩과 다를게 없게끔 문제를 풀고는 있는데, 
엔티티 5~6개를 조인해서 결과를 가져다 놔야하는데, 
IN 절로 

사이드 이펙트 
Stream 과 Map 을 이용해서 DB 레벨이 아닌 애플리케이션 레벨에서 조합해서 원래 스펙의 DTO

그랬더니 500개 나가던 쿼리가 20개로 줄어드는 

# 마치며
---


아니, **오히려 좋다.**

레거시라고 손 놓고 있을 수는 없다. 이참에 영한님의 기본
