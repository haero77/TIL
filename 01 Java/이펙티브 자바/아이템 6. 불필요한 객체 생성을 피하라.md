#팩토리메서드 #방어적복사 #오토박싱 #성능 #불변클래스

- [불필요한 객체 생성을 피하라](#%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%EC%9D%84%20%ED%94%BC%ED%95%98%EB%9D%BC)
		- [new String()을 피해야 하는 이유](#new%20String()%EC%9D%84%20%ED%94%BC%ED%95%B4%EC%95%BC%20%ED%95%98%EB%8A%94%20%EC%9D%B4%EC%9C%A0)
	- [정적 팩토리 메서드를 사용한 불필요한 객체 생성 막기](#%EC%A0%95%EC%A0%81%20%ED%8C%A9%ED%86%A0%EB%A6%AC%20%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%9C%20%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%20%EB%A7%89%EA%B8%B0)
		- [Boolean.valueOf(String)](#Boolean.valueOf(String))
	- [비싼 객체가 반복해서 필요하다면 캐싱해서 재사용하기](#%EB%B9%84%EC%8B%BC%20%EA%B0%9D%EC%B2%B4%EA%B0%80%20%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C%20%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4%EB%A9%B4%20%EC%BA%90%EC%8B%B1%ED%95%B4%EC%84%9C%20%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)
		- [String.matches](#String.matches)
		- [지연 초기화는 하지 말라](#%EC%A7%80%EC%97%B0%20%EC%B4%88%EA%B8%B0%ED%99%94%EB%8A%94%20%ED%95%98%EC%A7%80%20%EB%A7%90%EB%9D%BC)
- [박싱된 기본 타입보다는 기본 타입을 사용하라](#%EB%B0%95%EC%8B%B1%EB%90%9C%20%EA%B8%B0%EB%B3%B8%20%ED%83%80%EC%9E%85%EB%B3%B4%EB%8B%A4%EB%8A%94%20%EA%B8%B0%EB%B3%B8%20%ED%83%80%EC%9E%85%EC%9D%84%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
		- [오토 박싱 성능 비교](#%EC%98%A4%ED%86%A0%20%EB%B0%95%EC%8B%B1%20%EC%84%B1%EB%8A%A5%20%EB%B9%84%EA%B5%90)
- ['객체 생성은 비싸니 피해야한다'가 아니다.](#'%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%EC%9D%80%20%EB%B9%84%EC%8B%B8%EB%8B%88%20%ED%94%BC%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4'%EA%B0%80%20%EC%95%84%EB%8B%88%EB%8B%A4.)
		- ['객체 생성은 비싸니 피해야한다'가 아니다.](#'%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%EC%9D%80%20%EB%B9%84%EC%8B%B8%EB%8B%88%20%ED%94%BC%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4'%EA%B0%80%20%EC%95%84%EB%8B%88%EB%8B%A4.)
		- [직접 만든 객체 풀(pool)을 만들지 말자](#%EC%A7%81%EC%A0%91%20%EB%A7%8C%EB%93%A0%20%EA%B0%9D%EC%B2%B4%20%ED%92%80(pool)%EC%9D%84%20%EB%A7%8C%EB%93%A4%EC%A7%80%20%EB%A7%90%EC%9E%90)
- [새로운 객체를 만들어야한다면 기존 객체를 재사용하지마라](#%EC%83%88%EB%A1%9C%EC%9A%B4%20%EA%B0%9D%EC%B2%B4%EB%A5%BC%20%EB%A7%8C%EB%93%A4%EC%96%B4%EC%95%BC%ED%95%9C%EB%8B%A4%EB%A9%B4%20%EA%B8%B0%EC%A1%B4%20%EA%B0%9D%EC%B2%B4%EB%A5%BC%20%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80%EB%A7%88%EB%9D%BC)
		- [방어적 복사가 객체 반복 생성보다 더 중요하다.](#%EB%B0%A9%EC%96%B4%EC%A0%81%20%EB%B3%B5%EC%82%AC%EA%B0%80%20%EA%B0%9D%EC%B2%B4%20%EB%B0%98%EB%B3%B5%20%EC%83%9D%EC%84%B1%EB%B3%B4%EB%8B%A4%20%EB%8D%94%20%EC%A4%91%EC%9A%94%ED%95%98%EB%8B%A4.)



# 불필요한 객체 생성을 피하라

- 똑같은 기능의 객체를 매번 생성하기 보다, 객체 하나를 재사용하는 편이 나을 때가 많다.
	- 재사용은 빠르고 세련되며, 불변 객체(`아이템 17. 변경 가능성을 최소화하라`)는 언제든 재사용 가능하다.

### new String()을 피해야 하는 이유

```java
String s = new String("bikini");
```

- 위 문장은 실행될 때마다 String 인스턴스를 만든다.
- ***이 문장이 반복문, 또는 빈번히 호출되는 메서드 안에 있다면 쓸 데없는 String 인스턴스가 수백만 개 만들어질 수 있음.***

```java
String s = "bikini";
```

- 매번 인스턴스를 생성하지 않고, 하나의 인스턴스를 사용함.
- 같은 가상머신 안에서, 이 문자열 리터럴을 사용하는 **'모든' 코드가 같은 객체를 재사용함이 보장됨.**


## 정적 팩토리 메서드를 사용한 불필요한 객체 생성 막기

- `생성자 대신 적적 팩터리 메서드를 제공하는 불변 클래스` 에서는 정적 팩토리 메서드를 이용하여 불필요한 객체 생성을 줄일 수 있다. 예) Boolean.valueOf(String)

### Boolean.valueOf(String)

- `Boolean(String)` 생성자 대신 `Boolean.valueOf(String)` 을 사용하면 기존 인스턴스를 리턴한다.
	- 즉, 불필요한 객체 생성을 막는다. 
- 이런 경우, ***생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 전혀 그렇지 않다.***
	- (기존 인스턴스를 리턴하도록 구현하면 되므로)



## 비싼 객체가 반복해서 필요하다면 캐싱해서 재사용하기

- 생성 비용이 비싼 객체도 더러 있는데, 이런 '비싼 객체'가 반복해서 필요하다면 캐싱을 사용하자
	- 그러나, 내가 만드는 객체가 비싼 객체인지는 매번 명확히 판단할 수는 없음.

### String.matches

```java
static boolean isRomanNumeral(String s){  
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})" +  
            "(X[CL]|L?X{0,3})(I[XY]|V?I{0,3})$");  
}
```

- `String.matches` 를 사용하게 되면 내부적으로 `Pattern` 인스턴스를 만들고 한 번 쓰고 버려져서 바로 가비지 컬렉션 대상이 된다. 
	- Pattern 은 입력받은 정규 표현식에 해당하는 유한 상태 머신(infinite state machine???) 을 만들어서 생성 비용이 높다.


```java
public class RomanNumerals_After {  
  
    private static final Pattern ROMAN = Pattern.compile(  
            "^(?=.)M*(C[MD]|D?C{0,3})"  
                    + "(X[CL]|L?X{0,3})(I[XY]|V?I{0,3})$"  
    );  
  
    static boolean isRomanNumeral(String s) {  
        return ROMAN.matcher(s).matches();  
    }  
  
}
```

- 이렇게 개선하면 성능 개선이 가능하다.
- 코드도 명확해진다. 
	- 개선 전에는 **존재조차 몰랐던 Pattern 인스턴스를 static final 필드로 끄집어 내고 이름을 지어주어 코드의 의미가 훨씬 잘 드러난다.**


### 지연 초기화는 하지 말라

- 지연 초기화(아이템 83)는 불필요한 


# 박싱된 기본 타입보다는 기본 타입을 사용하라 

- 오토박싱은 불필요한 객체를 만들어내는 또 다른 예.
- **오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.**
	- 의미상으로는 별 다를 것 없지만, **성능에서는 그렇지 않다.** (`아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라`)


### 오토 박싱 성능 비교

```java
public static long sum() {  
    Long sum = 0L;  
  
    for (long i = 0; i < Integer.MAX_VALUE; i++) { 
        sum += i; // 오토박싱. 메서드 스택 프레임에 Long 인스턴스가 쌓인다.
    }  
  
    return sum;  
}
```

- `sum` 변수를 `long`이 아닌 `Long`으로 선언해서 불필요한 `Long` 인스턴스가 2^31개 만들어짐.
- `sum`을 `Long` 이 아닌 `long` 으로 바꿔주면 로컬 기준 6.3 -> 0.59 초 로 빨라졌다.

👉 ***박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.***


# '객체 생성은 비싸니 피해야한다'가 아니다.

### '객체 생성은 비싸니 피해야한다'가 아니다.

- `객체 생성은 비싸니 피해야 한다.` 라고 오해하면 안 된다.
	- 요즘 JVM 에서는 작은 객체를 생성하고 회수하는 일은 부담되지 않는다.
	- 프로그램의 명확성, 간결성, 기능을 위해서 추가적으로 객체를 생성하는 것은 일반적으로 좋은 것.

### 직접 만든 객체 풀(pool)을 만들지 말자

- 아주 무거운 객체가 아니고서야 객체 생성을 피하기 위한 객체 풀(pool)을 만들지 말자
- 객체 풀을 만드는 게 나은 경우는 있음
	- 예) 데이터베이스 커넥션 풀
- 일반적으로 자체 객체 풀은 코드를 헷갈리게 만들고, 메모리 사용량을 늘리며, 성능을 저하시킴
- 요즘 JVM 의 가비지 컬렉터는 최적화가 잘 되어있으니 직접 만든 객체 풀보다 훨씬 빠름



# 새로운 객체를 만들어야한다면 기존 객체를 재사용하지마라

- `아이템 6. 불필요한 객체 생성을 피하라` 은,
	- ***기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라*** 라는 이야기이다.
- `아이템 50. 적시에 방어적 복사본을 만들라` 는,
	- ***새로운 객체를 만들어야 한다면 기존 객체를 재사용 하지마라*** 라는 이야기이다.


### 방어적 복사가 객체 반복 생성보다 더 중요하다.

- **방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가, 필요 없는 객체를 반복 생성했을 때의 피해보다 훨씬 크다는 사실을 기억하라.**
	- (방어적 복사가 필요할 때 객체를 재사용하면 원본 레퍼런스가 훼손될 수 있으니까, 라는 이야기로 이해함)
- ***방어적 복사에 실패하면 잠재적인 버그와 보안 구멍으로 이어진다.***
	- 그러나 불필요한 객체 생성은 그저 코드 형태와 성능에만 영향을 준다.